\chapter{MIA Development \& Framework Features}
\pagestyle{fancy}






\section{Project Dependency Structure}
\label{sec:dependancy-structure}

The project is organized into layers to manage dependencies clearly:
\begin{itemize}\itemsep0em
\item Core: Contains fundamental types, error codes, and logging interfaces. It has no dependencies on other modules.
\item Utilities: Depend on Core and provide reusable helper functions like file and string operations.
\item Libraries: Depend on Core and Utilities, implementing domain-specific logic such as math functions.
\item Applications: Depend on Core, Utilities, and Libraries to build and run the final executable.
\end{itemize}
Modules within the same layer may depend on each other as needed. The key rule is to avoid circular dependencies between layers to maintain clear and manageable dependency flow. This layering ensures a unidirectional dependency flow, promoting modularity and easier maintenance. Details on utility modules can be found in Chapter \ref{chap:utilities}. Details on domain-specific libraries are in Chapter \ref{chap:libraries}.







\section{Build Script Overview}
\label{sec:build-script}

The build process for MIA is orchestrated through a Bash script, \texttt{build.sh}, located in the root directory of the project. This script automates common tasks involved in building, installing, and managing the application.

\subsection{Purpose}

The build script serves as a centralized interface for developers and users to:
\begin{itemize}\itemsep0em
	\item Configure and build the MIA project using CMake.
	\item Install the application on the system.
	\item Manage dependencies for supported platforms.
	\item Generate release builds.
	\item Clean the build environment for fresh compilation.
	\item Uninstall installed components.
\end{itemize}

\subsection{Key Functionalities}

The script supports a range of command-line options to control its behavior:
\begin{lstlisting}[style=terminalstyle]
$ ./build.sh -h

build: build.sh [options...]
This build script will automate the build and install of MIA.

Options:
    -h    Display this help message.
	-S    Run the initial setup to install dependancies and such. then exit.
	-C    Perform a clean build by removing the build directory first.
	-v    Enable verbose output during build process.
	-D    Attempt to Install dependencies.
	-I    Install MIA after building (requires admin). Use a clean build if errors occur.
	-R    Update the release files. Use a clean build if errors occur.
	-U    Uninstall all MIA files. This will uninstall then quit without other actions.
	-T    Run all tests.
	-d    Add flags to cmake for a debug build (useful if gdb is needed).
\end{lstlisting}
This build script is continually evolving and new options are added.

\subsubsection{Adding New Build Script Options}

To add a new option to the build script, a few things need considered. First, options must be unique. Each option should contain a short option argument (i.e. \inlinecode{-v, -h, -d}) as well as a description. These new options need added to the \texttt{usage} function and the \texttt{getopts} loop.
\begin{lstlisting}[style=shellstyle]
usage() # Create the usage output.
{
  # ...
  echo "  Options:"
  echo "    -f    Adding a new option with the -f flag."
  # Other entries...
}
\end{lstlisting}
\begin{lstlisting}[style=shellstyle]
# Define the build script options and create variables from options.
while getopts "hCvDIfRU" opt; do # Add the flag to the list here.
  case $opt in
    # Other entries...
    f) flagVariable=1 # Add flag actions here.
      ;;
    # Other entries...
  esac
done
\end{lstlisting}
The flag actions should be added to the getopts list (as seen above). These actions are typically setting a variable to store that the flag is used, then called later in the script. But functions or lists of other variables can be added here too.

\subsection{Platform Support}

The script contains conditional logic to perform platform-specific setup, with support primarily targeted at Linux environments. At the time of writing this, dependency installation scripts are stubbed for other platforms (e.g., macOS, Windows) but are not fully implemented.

\subsection{CMake Integration}

The build is managed via CMake, which is invoked with appropriate flags based on script options. A separate \texttt{build} directory is used to isolate generated files, and Make is used to compile the project with support for parallel jobs. See section \ref{sec:CMake-setup} for more details. The build script handles adding flags to the cmake configuration via the \texttt{cmakeArgs}. To add a flag to be used during the cmake build, add the appropriate flag to the \texttt{cmakeArgs} via the following:
\begin{lstlisting}[style=shellstyle]
cmakeArgs = "$cmakeArgs -DNEW_FLAG_HERE"
\end{lstlisting}

\subsection{Installation and Uninstallation}

Installation is optionally triggered using \texttt{cmake --install} followed by a custom installation script. Uninstallation is handled early in the script flow via a dedicated script and bypasses other operations. Although installation is handled via cmake, there are also separate install and uninstall scripts which are located in the scripts folder. These are setup to be called during the build script and are meant to implement additional install or uninstall steps. these are called via the following

\begin{lstlisting}[style=shellstyle]
$rootDirectory/scripts/install.sh
$rootDirectory/scripts/install.sh
\end{lstlisting}

\subsection{Design Considerations}

This script abstracts complexity away from the end user, provides a repeatable and configurable build process, and facilitates both development and deployment workflows. It is structured to be easily extendable for future platform support or additional build modes.










\section{C++ Macros}\label{sec:cpp_macros}
Macros are used sparingly within the framework, only when necessary to achieve concise and consistent code; whenever possible, inline functions or templates are preferred to maintain type safety and improve debuggability. Macros are employed within the application framework to provide concise, reusable code snippets that simplify common tasks and improve maintainability. They allow:
\begin{itemize}\itemsep0em
    \item \textbf{Code Reusability:} Encapsulate repetitive code patterns, reducing duplication and the chance for errors.
    \item \textbf{Consistent Behavior:} Enforce standardized procedures (e.g., logging conventions) across multiple classes and methods.
    \item \textbf{Ease of Use:} Provide simple interfaces for complex operations, enabling developers to invoke functionality with minimal syntax.
    \item \textbf{Conditional Logic:} Enable compile-time or runtime conditional behavior without adding verbose control flow code in the method body.
\end{itemize}
While macros can have drawbacks such as reduced type safety and debugging complexity, careful design and limited scope within the framework help mitigate these issues. The framework favors macros for lightweight abstraction where inline functions or templates would be overly verbose or less practical.
















\section{Cross-Platform Support}

The \texttt{MIA} project is designed to be cross-platform, with support for both Windows and Linux systems (and maybe more at later dates). This portability is achieved in part through the use of preprocessor macros that enable platform-specific compilation paths where necessary.

A key component of this system is the use of centralized platform detection macros defined in the \texttt{constants.hpp} file, which is included in the \texttt{Framework\_CORE} CMake library. These macros simplify platform checks throughout the codebase by abstracting away verbose compiler-defined flags. This code (which will look something like the example below) defines platform-specific macros, \texttt{IS\_WINDOWS} and \texttt{IS\_LINUX}, based on standard compiler-defined macros. The purpose is to centralize platform detection logic in one place for easier maintenance and extension when supporting additional platforms.

By defining \texttt{IS\_WINDOWS} when any common Windows-related macros are detected, and \texttt{IS\_LINUX} when the Linux macro \texttt{\_\_linux\_\_} is detected, the code enables simpler conditional compilation. Developers can then write platform-specific code using straightforward checks like \texttt{\#ifdef IS\_WINDOWS} or \texttt{\#if defined(IS\_LINUX)} rather than repeating complex or lengthy preprocessor conditionals throughout the codebase.

\begin{lstlisting}[style=cppstyle]
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || defined _WIN32 || defined _WIN64 || defined __CYGWIN__
	#define IS_WINDOWS
#elif defined(__linux__)
	#define IS_LINUX
#endif
\end{lstlisting}

By defining \texttt{IS\_WINDOWS} and \texttt{IS\_LINUX} in a single, shared header, platform-specific logic in the rest of the code can be expressed clearly and concisely using \texttt{\#ifdef} or \texttt{\#if defined(...)} blocks.















\section{CMake Setup}
\label{sec:CMake-setup}

The MIA project utilizes CMake to manage the build configuration, compilation, and installation processes. The setup is designed to be flexible and portable across supported platforms while allowing customization for release or system installation builds.

\subsection{Project Definition, Standards and Versioning}

The CMake configuration begins by specifying a minimum required CMake version and defining the project name \texttt{MIA} along with its version. The version is also passed as a preprocessor definition (\texttt{MIA\_VERSION\_VAL}) for use in the codebase. At the time of writing this, C++20 is set as the required language standard, and compiler warnings are enabled globally using the \texttt{-Wall} flag. The build directory path is stored in a variable for reference.

\subsection{Build Options}

Two primary options control build behavior:
\begin{itemize}\itemsep0em
	\item \texttt{RELEASE\_BUILD}: When enabled, modifies install paths and triggers release-specific build behavior.
	\item \texttt{SYSTEM\_INSTALL}: When enabled, configures installation paths and behaviors suitable for system-wide deployment.
	\item NOTE: The two build behaviors are somewhat incompatible and a clean build needs done when switching between them.
\end{itemize}

\subsection{Platform-Specific Path Configuration}

Installation paths and default directories for configuration files and logs are set depending on the operating system:
\begin{itemize}\itemsep0em
	\item \textbf{Windows:} Uses \texttt{C:/Program Files} for the install and \texttt{C:/ProgramData} for supporting files.
	\item \textbf{Linux/Unix:} Uses \texttt{/usr/local} for the install, \texttt{/etc} for supporting resource files, and \texttt{/var/log} for logging.
	\item Unsupported platforms produce a configuration error.
\end{itemize}
The cmake section that contains these configurations will give the exact file paths chosen for the various files. The actual CMake file should be used for gathering the current used paths (this documentation may become out-dated) which will be in a section similar to the following:
\begin{lstlisting}[style=shellstyle]
# OS-Specific Path Configuration
if(WIN32)
    set(APP_INSTALL_LOCATION "C:/Program Files/mia")
    set(DEFAULT_SYSTEM_CONFIG_FILE_DIR "C:/ProgramData/mia")
    set(DEFAULT_SYSTEM_LOG_DIR "C:/ProgramData/mia/logs")
elseif(UNIX AND NOT APPLE)
    set(APP_INSTALL_LOCATION "/usr/local/mia")
    set(DEFAULT_SYSTEM_CONFIG_FILE_DIR "/etc/mia")
    set(DEFAULT_SYSTEM_LOG_DIR "/var/log/mia")
else()
    message(FATAL_ERROR "Unsupported platform")
endif()
\end{lstlisting}

\subsection{Configuration Constants}

Both system-level and repository-level default paths for configuration and log files are defined and exposed to the compiler through compile-time definitions. This centralizes resource location information for consistent access across the codebase. To add a constant value defined in cmake such that it is accessible in the source code (c++), the following method can be used.

\subsubsection{Defining C++ Accessible CMake Variables}
\label{sec:CMake-setup-cpp}

First, the value needs defined in the CMake using the \texttt{set} and \texttt{add\_definiition} methods:
\begin{lstlisting}[style=shellstyle]
# The version of the current MIA code.
set(MIA_VERSION_VAL "2.001")

# Add MIAVERSION as a preprocessor variable.
add_definitions( -DMIA_VERSION_VAL=\"${MIA_VERSION_VAL}\" )
\end{lstlisting}
These values can then be accessed within the source C++ code directly via
\begin{lstlisting}[style=cppstyle]
// The MIA Version value gathered from CMake.
inline const std::string MIA_VERSION = MIA_VERSION_VAL;
\end{lstlisting}
These values are typically added within the \texttt{Constants\_LIB} files which contains system related MIA constants. 

\subsection{Project Structure and Targets}

The project is organized into subdirectories for executables, libraries, resources, and tests:

\begin{itemize}\itemsep0em
	\item \textbf{Executables:} Targets like \texttt{MIATemplate} are defined with source and header files, linked against core libraries, and have conditional install rules based on build options.
	\begin{lstlisting}[style=shellstyle]
# Create the MIATemplate executable.
set(MIATemplate_SRC MIATemplate.cpp MIATemplate_main.cpp )
set(MIATemplate_INC MIATemplate.hpp )
add_executable(MIATemplate ${MIATemplate_SRC} ${MIATemplate_INC} )
target_link_libraries(MIATemplate PRIVATE Core_LIB )

if(SYSTEM_INSTALL)
 install(TARGETS MIATemplate DESTINATION ${APP_INSTALL_LOCATION})
endif()

if(RELEASE_BUILD)
 install(TARGETS MIATemplate DESTINATION ${RELEASE_INSTALL_LOCATION})
endif()
	\end{lstlisting}
	\item \textbf{Libraries:} Utility libraries such as \texttt{Types\_LIB} are created from source files and expose their include directories for dependent targets. Libraries can link to other internal utilities or libraries.
	\begin{lstlisting}[style=shellstyle]
# Create the Types_LIB
set(Types_SRC StringUtils.cpp )
set(Types_INC StringUtils.hpp )
add_library(Types_LIB ${Types_SRC} ${Types_INC})
target_link_libraries( Types_LIB PUBLIC BasicUtilities_LIB )

# Expose this library's source directory for #include access by dependent targets
target_include_directories(Types_LIB PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
	\end{lstlisting}
	\item \textbf{Tests:} Test code is included via a dedicated subdirectory.
	\begin{lstlisting}[style=shellstyle]
# Include the test directory.
add_subdirectory( test )
	\end{lstlisting}
	\item \textbf{Resources:} Static resources are managed in their own subdirectory. These are primarily for configuration files and other resources. These are installed via the \texttt{FILES} Cmake keyword as follows:
	\begin{lstlisting}[style=shellstyle]
set(MIA_Config_Files
    MIATemplate.MIA
	# Other files here...
)

if(SYSTEM_INSTALL)
    install(FILES ${MIA_Config_Files} DESTINATION ${DEFAULT_SYSTEM_CONFIG_FILE_DIR})
endif()

if(RELEASE_BUILD)
    install(FILES ${MIA_Config_Files} DESTINATION ${RELEASE_CONFIG_INSTALL_LOCATION})
endif()
	\end{lstlisting}
\end{itemize}

\subsection{Installation Rules}

Conditional install commands allow targets to be installed either to system-wide locations or release-specific directories based on build flags (seen in the above shown cmake blocks). This supports flexible deployment workflows for development, testing, and production release. Overall, the CMake setup provides a structured, modular, and configurable build environment that adapts to different platforms and build scenarios while maintaining centralized control over important variables and paths.


















\section{Application Framework}
\label{sec:app-framework}

\subsection*{Overview}
The application framework provides a minimal structure for C++ applications that follow a consistent life cycle. It enforces a standard interface consisting of initialization and execution phases, and offers utilities to streamline application entry point definition. The design leverages C++20 concepts and templates for compile-time enforcement of interface contracts.

\subsection*{Life Cycle Model}
Applications using this framework must implement the following life cycle methods:
\begin{itemize}\itemsep0em
	\item \texttt{void initialize(int argc, char** argv)} \\
	Performs startup logic, such as argument parsing and resource allocation.
	\item \texttt{int run()} \\
	Contains the main execution logic of the application. The return value is propagated as the process exit code.
\end{itemize}

\subsection*{Interface Enforcement}
The framework uses a C++20 concept, \texttt{AppInterface}, to statically constrain application types. This ensures that any type passed to the launcher function conforms to the expected interface, eliminating runtime errors due to missing methods. Other types can be added to this interface if they are in the future and should conform to the same format as the currently existing ones. 

\begin{lstlisting}[style=cppstyle]
template<typename App>
concept AppInterface = requires(App app, int argc, char** argv) 
{
    { app.initialize(argc, argv) } -> std::same_as<void>;
    { app.run() } -> std::same_as<int>;
};
\end{lstlisting}

\subsection*{Application Launch}
Applications are launched using the \texttt{runApp} template function:
\begin{itemize}\itemsep0em
	\item Accepts any type satisfying \texttt{AppInterface}.
	\item Calls \texttt{initialize} followed by \texttt{run}, in that order.
	\item Returns the result of \texttt{run} as the application's exit code.
	\item Other method calls can be added in this sequence if they are needed in the future.
\end{itemize}
\begin{lstlisting}[style=cppstyle]
template<AppInterface App>
int runApp(int argc, char** argv)
{
    App app;
    app.initialize(argc, argv);
    return app.run();
}
\end{lstlisting}

\subsection*{Entry Point Definition}
To reduce boilerplate (code needing to be implemented by the end user) and unify application entry points, the framework provides an application macro entry point:
\begin{itemize}\itemsep0em
	\item \texttt{MIA\_MAIN(AppClass)} defines a \texttt{main()} function that delegates to \texttt{runApp<AppClass>}.
	\item This enables consistent startup across applications while preserving type safety and clarity.
\end{itemize}
\begin{lstlisting}[style=cppstyle]
#define MIA_MAIN(AppClass)                   \
int main(int argc, char** argv)              \
{                                            \
    return runApp<AppClass>(argc, argv);     \
}
\end{lstlisting}
This macro (along with the above defined interface) makes creating a main for an application simple and straight forward and provides consistent behavior across apps. Typically, for clarity, the user should define a separate main cpp file which contains the implementation of this interface.
\begin{lstlisting}[style=cppstyle]
// The MIA Application Framework templates
#include "AppFramework.hpp"
// The file containing the fishbot app.
#include "MIATemplate.hpp"

MIA_MAIN(MIATemplate)
\end{lstlisting}
Some tips and considerations follow:
\begin{enumerate}
	\item Define an application class that implements the required \texttt{initialize} and \texttt{run} methods.
	\item Use \texttt{MIA\_MAIN(YourAppClass);} in a translation unit to define the application entry point.
	\item Avoid manual \texttt{main()} definitions to preserve uniform lifecycle management.
\end{enumerate}

\subsection*{Benefits}
\begin{itemize}\itemsep0em
	\item Promotes a consistent lifecycle across applications.
	\item Enables interface enforcement at compile time.
	\item Minimizes boilerplate in entry point logic.
	\item Facilitates cleaner and more maintainable application architecture.
\end{itemize}











\section{Base Application Class: \texttt{MIAApplication}}
\label{sec:base-application}

\subsection*{Overview and Purpose}
The base MIA Application (see \texttt{MIAApplication.hpp}) serves as the foundational base class for applications built using the framework (See section \ref{sec:app-framework}). It defines a standardized interface for application life cycle methods and provides shared functionality for command-line argument parsing, particularly handling common flags such as \texttt{-v} (verbose) and \texttt{-h} (help). This class is intended to be sub-classed by MIA applications. It provides default behavior for argument parsing and flag handling, while enforcing the implementation of core logic via a pure virtual \texttt{run()} method. This ensures that the application framework templates and required concepts are enforced.

\subsection*{Initialization and Execution Interface}
\begin{itemize}\itemsep0em
	\item \texttt{virtual void initialize(int argc, char* argv[])} \\
	Handles initial setup, including parsing common command-line arguments. This method is intended to be overloaded to handle app-specific command line arguments and app loading. Derived classes should override this method to extend parsing logic but should still invoke the base implementation to preserve flag handling.
\end{itemize}

\begin{itemize}\itemsep0em
	\item \texttt{virtual int run() = 0} \\
	A pure virtual function that must be implemented by all derived classes. It defines the main operational logic of the application and must return an integer exit code.
\end{itemize}

\subsection*{Flag Handling}
\begin{itemize}\itemsep0em
	\item Verbose mode is handled internally and can be queried via \texttt{getVerboseMode()}.
	\item Help flag status is stored and can be utilized to trigger usage messages. When the help flag is specified, an application is automatically set to print the potentially-overloaded printHelp() method, print the help message, then exit the application.)
	\item \texttt{printHelp()} provides a virtual method to emit shared help information; it can be extended or overridden by subclasses. Derived classes should override this method to extend help output to be app specific but should still invoke the base implementation to preserve base command help options.
	\item A \texttt{logger::Logger logger} object is created with the optional \texttt{--logfile} flag setting a custom log file. This allows for easy logging by applications. This depends on application and user permissions in the case where the file path does not exist. The \texttt{logger} is stored as a private data member and meant to be hidden from the end-user. The logging functionality should be called via a \texttt{log(string)} method, which automatically handles verbose handling. See section \ref{sec:logging-Framework} for more details.
\end{itemize}

\subsection*{Protected Members}
\begin{itemize}\itemsep0em
	\item \texttt{bool verboseMode} \\
	Indicates whether verbose output was requested.
	\item \texttt{bool helpRequested} \\
	Set to \texttt{true} if the user requested help via the command-line.
\end{itemize}

\subsection*{Logging Macros}
To promote consistency and reduce boilerplate in logging method entry points, the application framework defines reusable macros for standardized logging. These macros improve traceability during debugging, especially when verbose mode is enabled.
\begin{itemize}\itemsep0em
    \item \texttt{LOG\_METHOD\_CALL(...)} logs the name of the calling method when it is entered. It uses the internal logger and respects the verbose mode flag. Optional parameters can be entered which allow the caller to specify a string of parameters or context data to include in the log output.
\end{itemize}
These macros are designed for use at the beginning of methods to ensure clear trace logging with minimal code overhead. They automatically utilize the \texttt{\_\_func\_\_} identifier for method name capture and rely on the internal \texttt{logger::Logger} instance.


\subsection*{Usage Guidelines}
An example application exists in \texttt{bin/apps/template} which demonstrates how the base application class is used.
\begin{enumerate}
	\item Inherit from \texttt{MIAApplication}.
	\begin{lstlisting}[style=cppstyle]
class MIATemplate : public MIAApplication
{ // Class details... }
	\end{lstlisting}
 
	\item Override \texttt{initialize()} to add application-specific argument parsing; call the base method to retain common flag handling at the start of the application initialize() implementation.
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::initialize(int argc, char* argv[])
{
	try
	{    
		MIAApplication::initialize(argc, argv);	
		// Setup app-specific command line arguments here...
	}
	catch (const error::MIAException& ex)
	{
		std::cerr << "Error during MIATemplate::initialize: " << ex.what() << std::endl;
		// Handle error appropriately...
	}
	
	// Other init code...
}
	\end{lstlisting}
 
	\item Implement the \texttt{run()} method with the application's main logic.
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::run()
{
	// Perform app functions...
}
	\end{lstlisting}
 
	\item Use \texttt{getVerboseMode()} to conditionally enable verbose output (if the verbose flag was used when running the application).
	\begin{lstlisting}[style=cppstyle]
if (getVerboseMode())
    std::cout << "This is verbose output!" << std::endl;
	\end{lstlisting}
 
	\item Override \texttt{printHelp()} to add help output specific to the application. Call the base method to retain base application help menu output.
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::printHelp() const
{
    MIAApplication::printHelp();
    
    std::cout << "MIATemplate specific options:" << std::endl
              // Add app-specific help output here...
              << std::endl;
}
	\end{lstlisting}
 
	\item Call the \texttt{log()} method in order to log information.
	\begin{lstlisting}[style=cppstyle]
log("This is a message to log");
	\end{lstlisting}
	In the rare case that the user wants to overload the standard verbose handling, an overloaded \texttt{log(string, bool)} method exists which accepts a verbose flag as the second argument.
	\begin{lstlisting}[style=cppstyle]
log("This is a message to log", true);
	\end{lstlisting}
 
	 \item Use the \texttt{LOG\_METHOD\_CALL()} macro at the start of methods to automatically log method entry points. These macros use the internal logger and respect the verbose mode flag.
	\begin{lstlisting}[style=cppstyle]
void MyClass::compute()
{
    LOG_METHOD_CALL(); // Logs method entry if verbose mode is enabled
    // ...
}

void MyClass::computeWithInput(int x)
{
    LOG_METHOD_CALL("x=" + std::to_string(x));
    // ...
}
	\end{lstlisting}
\end{enumerate}

\subsection*{Benefits}
\begin{itemize}\itemsep0em
	\item Standardizes life cycle structure across applications.
	\item Centralizes command-line flag logic.
	\item Reduces redundancy in application setup.
	\item Encourages consistent help and verbose interfaces.
\end{itemize}










\section{Command Option System}
\label{sec:cmd-option-system}

The command option system provides structured parsing and management of command-line arguments. It is composed of two main components: the \texttt{CommandOption} class and the \texttt{command\_parser} namespace. Together, they offer a consistent and type-safe interface for defining, parsing, and validating command-line options. An example application exists in \texttt{bin/apps/template} which demonstrates how the command options can be used.

\subsection{CommandOption Class}

The \texttt{CommandOption} class encapsulates metadata and behavior for individual command-line arguments. It supports a variety of data types and provides a standardized help display format.

\subsubsection*{Key Features}
\begin{itemize}\itemsep0em
	\item \textbf{Supported Types:} These define the type of command option that is expected. Each command option should only have one expected type which is defined by the \texttt{commandOptionType} enum:
	\begin{itemize}\itemsep0em
		\item \texttt{boolOption}: A single command flag to store true when used (false otherwise).
		\item \texttt{intOption}: A command flag followed by an integer.
		\item \texttt{doubleOption}: A command flag option followed by a double.
		\item \texttt{stringOption}: A command flag option followed by a string.
	\end{itemize}
	
	\item \textbf{Constructor:} Accepts short/long argument forms, a description, data type, and a \texttt{required} flag. This constructor should be called during construction for the application class. This constructor sets the command option flags, description, and the type; all of which are needed during initialization to enable command option output and parsing.
	\begin{lstlisting}[style=cppstyle]
MIATemplate::MIATemplate() : 
    configFileOpt("-c", "--config", "Specify a config file to use.",
        CommandOption::commandOptionType::stringOption),
    testOpt("-t", "--test", "A test command option.",
        CommandOption::commandOptionType::boolOption)            
{ };
	\end{lstlisting}
	
	\item \textbf{Help Output:} \texttt{getHelp()} returns a formatted string of the form:
	\begin{lstlisting}
-s, --long        Description
	\end{lstlisting}
	This method is intended to return a string for each command option in a consistent format in order to make constructing the overridden printHelp() message of the base application class simpler. The getHelp() method can be used in constructing the help message for an app in a way similar to the following:
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::printHelp() const
{
 MIAApplication::printHelp();
 
 // This is a dump of the help messages used by the various command options.
 std::cout << "MIATemplate specific options:" << std::endl
           << configFileOpt.getHelp() << std::endl
           << testOpt.getHelp() << std::endl
           << std::endl;
}
	\end{lstlisting}
	\item \textbf{Value Parsing:} The \texttt{getOptionVal<Type>} method retrieves the typed value from the command-line using appropriate dispatch. This is typically done during app initialization and serves to simplify the process of parsing command line options by allowing a single method to get and set the appropriate variables.
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::initialize(int argc, char* argv[])
{
    try
    {    
        MIAApplication::initialize(argc, argv);

        // Set the values from the command line arguments.
        testOpt.getOptionVal<bool>(argc, argv, testMode);
        
        std::string configFile = defaultConfigFile;
        configFileOpt.getOptionVal<std::string>(argc, argv, configFile);
        config.setConfigFileName(configFile, constants::ConfigType::KEY_VALUE); // handles config.initialize().
    }
    catch (const error::MIAException& ex)
    {
        std::cerr << "Error during MIATemplate::initialize: " << ex.what() << std::endl;
    }
}
	\end{lstlisting}
	
	\item \textbf{Error Handling:} Throws \texttt{MIAException} if a type mismatch occurs or parsing fails.
\end{itemize}

\subsection{command\_parser Namespace}

This namespace implements the actual logic for extracting typed values from \texttt{argc}/\texttt{argv}. Each function accepts short and long option names, and a reference to the variable where the parsed value should be stored.

\subsubsection*{Parsing Functions}
\begin{itemize}\itemsep0em
	\item \texttt{void parseBoolFlag(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, bool\& outValue);}
	\item \texttt{void parseIntOption(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, int\& outValue, bool required = false);}
	\item \texttt{void parseDoubleOption(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, double\& outValue, bool required = false);}
	\item \texttt{void parseStringOption(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, std::string\& outValue, bool required = false);}
\end{itemize}

\subsubsection*{Behavior and Integration}
Each parser:
\begin{itemize}\itemsep0em
	\item Validates the presence of the option.
	\item Converts the argument to the correct type.
	\item Throws a \texttt{MIAException} on error, such as type mismatch or missing required value.
\end{itemize}
The \texttt{CommandOption} class acts as a high-level interface, while \texttt{command\_parser} performs the low-level parsing. Together, they ensure robustness, type safety, and consistent error reporting across the command-line interface.














\section{Error Handling Framework}
\label{sec:error-handling}

\subsection*{Overview}
The MIA error handling system provides a structured and consistent mechanism for reporting, categorizing, and propagating errors throughout MIA applications. It is centered around a custom exception type (\texttt{MIAException}) and an extensible set of error codes defined via the \texttt{ErrorCode} enumeration.

\subsection*{Error Codes}
The \texttt{ErrorCode} enumeration defines a comprehensive list of standardized error values used throughout the MIA framework. These include:
\begin{itemize}\itemsep0em
	\item System-aligned codes (e.g., \texttt{Access\_denied = 5})
	\item Application-specific codes starting at 31415 (i.e., \texttt{int}($\pi$ × 10000)), e.g., \texttt{Feature\_In\_Dev}
	\item Custom fatal and configuration errors (e.g., \texttt{FATAL\_File\_Not\_Found}, \texttt{Config\_File\_Not\_Set})
\end{itemize}

Each error code is associated with a human-readable description defined in \texttt{ErrorDescriptions.hpp}, accessible via:
\begin{lstlisting}[style=cppstyle]
const std::string& getErrorDescription(ErrorCode code);
\end{lstlisting}

\subsection*{MIAException Class}
The primary mechanism for structured error propagation is the \texttt{MIAException} class:
\begin{itemize}\itemsep0em
	\item Inherits from \texttt{std::exception}.
	\item Encapsulates an \texttt{ErrorCode} and an optional detailed message.
	\item Supports integration with standard C++ \texttt{try/catch} error handling.
\end{itemize}

\textbf{Interface Summary:}
\begin{itemize}\itemsep0em
	\item \texttt{MIAException(ErrorCode, const std::string\& details = "")} \\
	Constructs an exception with a specific code and optional extra context.
	\item \texttt{const char* what() const noexcept} \\
	Returns a descriptive error string combining code-based and contextual information.
	\item \texttt{ErrorCode getCode() const noexcept} \\
	Retrieves the error code associated with the exception.
\end{itemize}

\subsection*{Deprecated Legacy Functions}
Several older functions exist but are marked deprecated in favor of \texttt{MIAException}:
\begin{itemize}\itemsep0em
	\item \texttt{returnError()}, \texttt{errorInfo()}, and \texttt{errorInfoRun()} are retained for backward compatibility but should be avoided.
	\item These are flagged with \texttt{[[deprecated]]} attributes.
\end{itemize}


\subsection*{Exception Throwing Macro}
To streamline exception throwing and ensure consistent inclusion of contextual metadata, the framework defines a macro \texttt{MIA\_THROW(code, ...)}. This macro reduces boilerplate when throwing exceptions while ensuring that the error message includes file, line, and function information. This contextual data is critical for debugging and tracing issues during runtime. Instead of manually constructing exception messages with source location details, developers can use this macro for clarity and convenience:
\begin{lstlisting}[style=cppstyle]
if (!configLoaded)
{
    MIA_THROW(error::ErrorCode::Config_File_Not_Set, "Configuration missing");
}
\end{lstlisting}
The macro assists with the following features:
\begin{itemize}\itemsep0em
    \item Automatically captures and appends \texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_}, and \texttt{\_\_func\_\_}.
    \item Accepts an optional message string describing the error context.
    \item Safely wrapped in a \texttt{do \{...\} while(0)} block for predictable macro expansion.
\end{itemize}
This macro enhances code readability, enforces consistent exception formatting, and aids postmortem analysis or log review. It should be preferred over manual \texttt{MIAException} construction unless special behavior is required.



\subsection*{Usage Guidelines}
\begin{enumerate}
	\item Throw \texttt{MIAException} in place of manual error returns. An appropriate error code from \texttt{error::ErrorCodes} should be used. If one does not exist, one should be added.
	\begin{lstlisting}[style=cppstyle]
if (someErrorCondition) 
{
    std::string err = "Details of this error!";
    throw error::MIAException(error::ErrorCode::Catastrophic_Failure, err); 
}
	\end{lstlisting}
	\item Throw \texttt{MIAException} using the pre-defined macro if file name, line number, and method name are desired in the output. An appropriate error code from \texttt{error::ErrorCodes} should be used. If one does not exist, one should be added.
	\begin{lstlisting}[style=cppstyle]
if (someErrorCondition) 
{
    std::string err = "Details of this error!";
    THROW_MIA_EXCEPTION(error::ErrorCode::Catastrophic_Failure, err); 
}
	\end{lstlisting}
	\item Use \texttt{getErrorDescription()} to log or report known error codes.
	\item Check exception codes via \texttt{getCode()} in catch blocks to take context-specific actions.
	\begin{lstlisting}[style=cppstyle]
catch (const error::MIAException& ex)
{
    if (ex.getCode() == error::ErrorCode::Catastrophic_Failure)
    {
    	// Do something specific for this error.
    }
}
	\end{lstlisting}
	\item Add new error codes and descriptions for error-specific handling and information gathering to ensure that apps remain transparent and easy to use.
	\begin{lstlisting}[style=cppstyle]
// In bin/core/Error.hpp
namespace error
{
    enum ErrorCode
    {
    	New_Error = 31450 // Add error codes here
    }
}
	\end{lstlisting}
	\begin{lstlisting}[style=cppstyle]
// In bin/core/Errordescriptions.cpp
namespace error
{
    const std::unordered_map<ErrorCode, std::string> errorDescriptions = {
    	// Other error code descriptions here...
        { New_Error, "Add error description here..." },
    };
	\end{lstlisting}
\end{enumerate}

\subsection*{Benefits}
\begin{itemize}\itemsep0em
	\item Unifies error handling across the application ecosystem.
	\item Enables richer debugging and logging through descriptive errors.
	\item Supports granular response logic based on typed error codes.
\end{itemize}








\section{Global Constants and Paths}
\label{sec:global-constants-and-paths}

This section documents the centralized constants and path utilities used across the application. These components standardize access to configuration values, resource locations, and metadata such as the application version. See section \ref{sec:CMake-setup-cpp} for some related information on adding global paths and compile time through CMake.

\subsection{constants Namespace}

The \texttt{constants} namespace provides globally accessible constant values compiled into the application.

\subsubsection*{Defined Constant}
\begin{itemize}\itemsep0em
	\item \texttt{MIA\_VERSION}: A \texttt{std::string} representing the version of the MIA application, injected from CMake via the \texttt{MIA\_VERSION\_VAL} macro.
\end{itemize}

\subsection{paths Namespace}

The \texttt{paths} namespace offers a centralized interface for accessing directory and file paths used by the system. These include installation-specific and repository-relative locations, as well as runtime-determined paths.

\subsubsection*{Static Path Constants}
\begin{itemize}\itemsep0em
	\item \texttt{SYSTEM\_CONFIG\_FILE\_DIR}, \texttt{SYSTEM\_CONFIG\_FILE}: Paths to the configuration directory and file for system installations.
	\item \texttt{REPO\_CONFIG\_FILE\_DIR}, \texttt{REPO\_CONFIG\_FILE}: Paths used during development and testing.
	\item \texttt{SYSTEM\_LOG\_DIR}, \texttt{SYSTEM\_LOG}: Default logging directory and file when installed.
	\item \texttt{REPO\_LOG\_DIR}, \texttt{REPO\_LOG}: Logging paths for repository use.
	\item \texttt{INSTALL\_LOCATION}: The root directory of the system installation.
\end{itemize}

\subsubsection*{Runtime Utilities} \label{sec:global-constants-utilities}
\begin{itemize}\itemsep0em
	\item \texttt{getExecutableDir()}: Returns the absolute directory of the running executable using platform-specific APIs.
	
	\item \texttt{isInstalled()}: Determines whether the application is running from the system-installed location by comparing the executable path with the install directory.
	
	\item \texttt{getDefaultConfigDirToUse()}: Selects the configuration directory based on execution context:
	\begin{itemize}\itemsep0em
		\item If installed: returns \texttt{SYSTEM\_CONFIG\_FILE\_DIR}.
		\item If a \texttt{resources} folder exists in the executable directory: returns that path.
		\item Otherwise: returns \texttt{REPO\_CONFIG\_FILE\_DIR}.
	\end{itemize}
	This is particularly useful when determining the full path of a configuration file to use. The application will automatically try to detect which file to use based on its location and which files are available. This allows for portability and flexibility.
\end{itemize}

This design ensures portability and flexibility across different environments (development, testing, deployment), with consistent fallback logic and platform-agnostic path resolution.




















\section{Configuration System}
\label{sec:configuration-system}

The \texttt{MIAConfig} class provides a flexible and extensible interface for managing configuration data in the MIA system. It replaces the legacy \texttt{Configurator} from the previous MIA project. The system is designed using the PIMPL (Pointer to IMPLementation) idiom, encapsulating implementation details and allowing for multiple configuration types such as key-value pairs or raw-line formats (with the flexibility to add more later).

\subsection{Overview}

\begin{itemize}\itemsep0em
	\item \texttt{MIAConfig} is the main public interface that users interact with.
	\item \texttt{ConfigData} is an abstract base class defining the interface for internal configuration storage.
	\item \texttt{KeyValueData} is a concrete implementation of \texttt{ConfigData::KEY\_VALUE}, supporting standard key-value format parsing and access.
	\item \texttt{RawLinesData} is a concrete implementation of \texttt{ConfigData::RAW\_LINES}, supporting raw line format parsing and access.
	\item Configuration types are enumerated via \texttt{constants::ConfigType}.
\end{itemize}

\subsection{Key Features}

\begin{itemize}\itemsep0em
	\item Supports setting and retrieving configuration files and types dynamically.
	\item Provides typed accessors: \texttt{getInt()}, \texttt{getDouble()}, \texttt{getString()}, \texttt{getBool()}, and vector versions.
	\item Supports verbose logging during file parsing for debugging.
	\item Can return all configuration entries as key-value pairs, raw lines, or other formats depending on the format and implementation details.
\end{itemize}

\subsection{Class Hierarchy and Responsibilities}

\begin{description}
	\item[\texttt{MIAConfig}] 
	\hfill \\
	Acts as the front-end API. It delegates all data handling to the \texttt{ConfigData} object through a \texttt{std::unique\_ptr}.
	
	\item[\texttt{ConfigData}] 
	\hfill \\
	Abstract base class defining the required interface for data handling implementations. Includes methods for loading, retrieving, and dumping configuration data.
	
	\item[\texttt{KeyValueData}]
	\hfill \\
	Implements \texttt{ConfigData}. Parses files formatted with \texttt{key=value} lines into an internal map and supports type conversion and retrieval.
	
	\item[\texttt{RawLinesData}]
	\hfill \\
	Implements \texttt{ConfigData}. Parses files formatted with \texttt{any} format (parsed by line) into an internal vector and supports retrieval for custom parsing.
\end{description}

\subsection{Usage Pattern}

\begin{enumerate}
	\item Include a configuration object as a private member of the application class for each configuration file which is needed (used) by the application.
	\begin{lstlisting}[style=cppstyle]
/// The configuration loader for this app.
config::MIAConfig config;
	\end{lstlisting}
	\item Instantiate \texttt{MIAConfig} with a file name and configuration type. This should be done at application construction so that the configuration is available to parse and use during initialization. A default configuration file name can be defined and used at object construction or defined later. The file name can contain a full file path, but if it does not, the MIAConfig class will attempt to identify an appropriate configuration directory during config initialization using the \texttt{paths::getDefaultConfigDirToUse()} method (see section \ref{sec:global-constants-utilities} for more details).
	\begin{lstlisting}[style=cppstyle]
MIATemplate::MIATemplate() : 
	config(defaultConfigFile, constants::ConfigType::KEY_VALUE)                      
{ };
	\end{lstlisting}
	\textbf{Important:} If you create a private data member within a class for a default configuration file, that variable must be constructed before the \texttt{MIAConfig} object.
	\begin{lstlisting}[style=cppstyle]
// This is the CORRECT usage.
class WoWFishbot {
public:
	WoWFishbot() : config(defaultConfigFile, constants::ConfigType::KEY_VALUE)
private:
	std::string defaultConfigFile{"WoWConfig.MIA"};
	config::MIAConfig config;
}
	\end{lstlisting}
	\begin{lstlisting}[style=cppstyle]
// This is the INCORRECT usage.
class WoWFishbot {
public:
	WoWFishbot() : config(defaultConfigFile, constants::ConfigType::KEY_VALUE)
private:
	config::MIAConfig config;
	std::string defaultConfigFile{"WoWConfig.MIA"};
}

// Throws this error:
terminate called after throwing an instance of 'std::bad_alloc'
what():  std::bad_alloc
	\end{lstlisting}
	\item Call \texttt{initialize()}, \texttt{reload()} or \texttt{setConfigFileName(..)} during application initialization to parse and load the base configuration file into the appropriate config implementation (this is based on the specified configuration type).
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::initialize(int argc, char* argv[])
{
	try
	{    
		// Other code...
		std::string configFile = defaultConfigFile;
		configFileOpt.getOptionVal<std::string>(argc, argv, configFile);
		
		// This will call config.initialize().
		config.setConfigFileName(configFile, constants::ConfigType::KEY_VALUE);
	}
	// Optionally print the config values after it is loaded.
	if (getVerboseMode())
		config.dumpConfigMap();
	
	loadConfig(); // An app-specific config loader.
}
	\end{lstlisting}
	\item Use the typed getter methods to retrieve settings from the config class and store them into application-specific variables.
	\begin{lstlisting}[style=cppstyle]
void MIATemplate::loadConfig()
{
	try
	{
		// Load configuration here.
		configFileVals.boolValue = config.getBool("MyBoolValue");
		configFileVals.intValue = config.getInt("myIntValue");
		configFileVals.doubleValue = config.getDouble("myDoubleValue");
		configFileVals.stringValue = config.getString("myStringValue");
		configFileVals.listValue = config.getVector("myListValue", ',');
	}
	catch (error::MIAException& ex)
	{ // Handle errors... }
}
	\end{lstlisting}
\end{enumerate}

\subsection{Quick Example}

Consider a configuration file containing an integer value with a key of `network.timeout'
\begin{lstlisting}[style=cppstyle]
# This is the settings.conf file.
network.timeout=15
\end{lstlisting}
You can collect that value using the following: 
\begin{lstlisting}[style=cppstyle]
MIAConfig cfg("settings.conf", constants::ConfigType::KEY_VALUE);
cfg.initialize();
int timeout = cfg.getInt("network.timeout");
\end{lstlisting}

\subsection{Extensibility}

New configuration formats can be supported by deriving new classes from \texttt{ConfigData} and implementing the required interface. \texttt{MIAConfig} will manage the polymorphic pointer and delegate appropriately based on the \texttt{ConfigType}.
























\section{Logging Framework}
\label{sec:logging-Framework}

\subsection{Overview}
The \texttt{Logger} component provides centralized logging functionality for all MIA applications. It supports simple log message recording to either a default or user-defined log file, with optional verbosity to print messages to \texttt{stdout}.

\subsection{Free Logging Functions}
Three free-standing functions are provided for lightweight, context-independent logging:

\begin{itemize}\itemsep0em
	\item \texttt{logToDefaultFile(message, verbose = false)}\\
	Logs a message to a default log file (typically \texttt{MIA.log}). If \texttt{verbose} is \texttt{true}, the message is also printed to \texttt{stdout}.
	
	\item \texttt{logToFile(message, filename, verbose = false)}\\
	Logs a message to a specified file. If only a filename is provided (not a full path), the path is resolved using \texttt{paths::getDefaultLogDirToUse()}. Assumes the target directory exists. Supports optional verbosity.

 	\item \texttt{void logMethodCallToFile(methodName, filename, params = "", verbose = false)}\\
  	Logs a message to the specified file which contains the method name and optional parameters. This method is intended to be called with \texttt{\_\_func\_\_} as the methodName from some other method call in order to track and log that method entry. This message is somewhat redundant alongside \texttt{logToFile}, though it's formatted specifically to be used with some various application framework macros which pre-format some of the arguments (i.e. methodName). See \ref{sec:base-application} to see how these macros are (and should be) called. If only a filename is provided (not a full path), the path is resolved using \texttt{paths::getDefaultLogDirToUse()}. Assumes the target directory exists. Supports optional verbosity.
\end{itemize}

\subsection{The \texttt{Logger} Class}
For more structured applications, the \texttt{Logger} class provides an object-oriented interface for managing log state:

\begin{itemize}\itemsep0em
	\item \texttt{Logger(filename = DEFAULT\_LOG\_FILE)}\\
	Constructor that initializes logging to the specified file. If not provided, defaults to \texttt{MIA.log}.
	
	\item \texttt{setLogFile(filename)}\\
	Changes the log file during runtime. Closes the existing stream and opens a new one.
	
	\item \texttt{log(message, verbose = false)}\\
	Logs a message to the current file. If \texttt{verbose} is enabled, also prints to \texttt{stdout}.
	
	\item \texttt{getLogFile()}\\
	Returns the current log file name in use.
\end{itemize}

\subsection{Internals}
Internally, the \texttt{Logger} class maintains:

\begin{itemize}\itemsep0em
	\item \texttt{currentLogFileName} -- User-specified or default log filename.
	\item \texttt{currentLogFileFullPath} -- Resolved full path for the log file.
	\item \texttt{logStream} -- A mutable \texttt{std::ofstream} used for log writes.
\end{itemize}

The method \texttt{openLogFile()} is called during construction and when switching log files, ensuring the stream is always open and ready for use.

\subsection{Summary}
This logging framework simplifies and unifies log message handling across MIA tools. It supports both procedural and object-oriented usage styles, allows runtime control over log destinations, and integrates with the system's standard output for interactive diagnostics.





