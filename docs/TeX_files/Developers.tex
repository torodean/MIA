\chapter{MIA Development}
\pagestyle{fancy}






\section{Project Dependency Structure}

The project is organized into layers to manage dependencies clearly:
\begin{itemize}
\item Core: Contains fundamental types, error codes, and logging interfaces. It has no dependencies on other modules.
\item Utilities: Depend on Core and provide reusable helper functions like file and string operations.
\item Libraries: Depend on Core and Utilities, implementing domain-specific logic such as math functions.
\item Applications: Depend on Core, Utilities, and Libraries to build and run the final executable.
\end{itemize}
Modules within the same layer may depend on each other as needed. The key rule is to avoid circular dependencies between layers to maintain clear and manageable dependency flow. This layering ensures a unidirectional dependency flow, promoting modularity and easier maintenance.






\section{Build Script Overview}
\label{sec:build-script}

The build process for MIA is orchestrated through a Bash script, \texttt{build.sh}, located in the root directory of the project. This script automates common tasks involved in building, installing, and managing the application.

\subsection{Purpose}

The build script serves as a centralized interface for developers and users to:
\begin{itemize}
	\item Configure and build the MIA project using CMake.
	\item Install the application on the system.
	\item Manage dependencies for supported platforms.
	\item Generate release builds.
	\item Clean the build environment for fresh compilation.
	\item Uninstall installed components.
\end{itemize}

\subsection{Key Functionalities}

The script supports a range of command-line options to control its behavior:
\begin{lstlisting}[style=terminalstyle]
$ ./build.sh -h

build: build.sh [options...]
This build script will automate the build and install of MIA.

Options:
	-h    Display this help message.
	-C    Perform a clean build by removing the build directory first.
	-v    Enable verbose output during build process.
	-D    Attempt to Install dependencies.
	-I    Install MIA after building (requires admin). Use a clean build if errors occur.
	-R    Update the release files. Use a clean build if errors occur.
	-U    Uninstall all MIA files. This will uninstall then quit without other actions.
\end{lstlisting}
This build script is continually evolving and new options are added.

\subsubsection{Adding New Build Script Options}

To add a new option to the build script, a few things need considered. First, options must be unique. Each option should contain a short option argument (i.e. \inlinecode{-v, -h, -d}) as well as a description. These new options need added to the \texttt{usage} function and the \texttt{getopts} loop.
\begin{lstlisting}[style=shellstyle]
usage() # Create the usage output.
{
  # ...
  echo "  Options:"
  echo "    -f    Adding a new option with the -f flag."
  # Other entries...
}
\end{lstlisting}
\begin{lstlisting}[style=shellstyle]
# Define the build script options and create variables from options.
while getopts "hCvDIfRU" opt; do # Add the flag to the list here.
  case $opt in
    # Other entries...
    f) flagVariable=1 # Add flag actions here.
      ;;
    # Other entries...
  esac
done
\end{lstlisting}
The flag actions should be added to the getopts list (as seen above). These actions are typically setting a variable to store that the flag is used, then called later in the script. But functions or lists of other variables can be added here too.

\subsection{Platform Support}

The script contains conditional logic to perform platform-specific setup, with support primarily targeted at Linux environments. At the time of writing this, dependency installation scripts are stubbed for other platforms (e.g., macOS, Windows) but are not fully implemented.

\subsection{CMake Integration}

The build is managed via CMake, which is invoked with appropriate flags based on script options. A separate \texttt{build} directory is used to isolate generated files, and Make is used to compile the project with support for parallel jobs. See section \ref{sec:CMake-setup} for more details. The build script handles adding flags to the cmake configuration via the \texttt{cmakeArgs}. To add a flag to be used during the cmake build, add the appropriate flag to the \texttt{cmakeArgs} via the following:
\begin{lstlisting}[style=shellstyle]
cmakeArgs = "$cmakeArgs -DNEW_FLAG_HERE"
\end{lstlisting}

\subsection{Installation and Uninstallation}

Installation is optionally triggered using \texttt{cmake --install} followed by a custom installation script. Uninstallation is handled early in the script flow via a dedicated script and bypasses other operations. Although installation is handled via cmake, there are also separate install and uninstall scripts which are located in the scripts folder. These are setup to be called during the build script and are meant to implement additional install or uninstall steps. these are called via the following

\begin{lstlisting}[style=shellstyle]
$rootDirectory/scripts/install.sh
$rootDirectory/scripts/install.sh
\end{lstlisting}

\subsection{Design Considerations}

This script abstracts complexity away from the end user, provides a repeatable and configurable build process, and facilitates both development and deployment workflows. It is structured to be easily extendable for future platform support or additional build modes.















\section{CMake Setup}
\label{sec:CMake-setup}

The MIA project utilizes CMake to manage the build configuration, compilation, and installation processes. The setup is designed to be flexible and portable across supported platforms while allowing customization for release or system installation builds.

\subsection{Project Definition, Standards and Versioning}

The CMake configuration begins by specifying a minimum required CMake version and defining the project name \texttt{MIA} along with its version. The version is also passed as a preprocessor definition (\texttt{MIA\_VERSION\_VAL}) for use in the codebase. At the time of writing this, C++20 is set as the required language standard, and compiler warnings are enabled globally using the \texttt{-Wall} flag. The build directory path is stored in a variable for reference.

\subsection{Build Options}

Two primary options control build behavior:
\begin{itemize}
	\item \texttt{RELEASE\_BUILD}: When enabled, modifies install paths and triggers release-specific build behavior.
	\item \texttt{SYSTEM\_INSTALL}: When enabled, configures installation paths and behaviors suitable for system-wide deployment.
	\item NOTE: The two build behaviors are somewhat incompatible and a clean build needs done when switching between them.
\end{itemize}

\subsection{Platform-Specific Path Configuration}

Installation paths and default directories for configuration files and logs are set depending on the operating system:
\begin{itemize}
	\item \textbf{Windows:} Uses \texttt{C:/Program Files} for the install and \texttt{C:/ProgramData} for supporting files.
	\item \textbf{Linux/Unix:} Uses \texttt{/usr/local} for the install, \texttt{/etc} for supporting resource files, and \texttt{/var/log} for logging.
	\item Unsupported platforms produce a configuration error.
\end{itemize}
The cmake section that contains these configurations will give the exact file paths chosen for the various files. The actual CMake file should be used for gathering the current used paths (this documentation may become out-dated) which will be in a section similar to the following:
\begin{lstlisting}[style=shellstyle]
# OS-Specific Path Configuration
if(WIN32)
    set(APP_INSTALL_LOCATION "C:/Program Files/mia")
    set(DEFAULT_SYSTEM_CONFIG_FILE_DIR "C:/ProgramData/mia")
    set(DEFAULT_SYSTEM_LOG_DIR "C:/ProgramData/mia/logs")
elseif(UNIX AND NOT APPLE)
    set(APP_INSTALL_LOCATION "/usr/local/mia")
    set(DEFAULT_SYSTEM_CONFIG_FILE_DIR "/etc/mia")
    set(DEFAULT_SYSTEM_LOG_DIR "/var/log/mia")
else()
    message(FATAL_ERROR "Unsupported platform")
endif()
\end{lstlisting}

\subsection{Configuration Constants}

Both system-level and repository-level default paths for configuration and log files are defined and exposed to the compiler through compile-time definitions. This centralizes resource location information for consistent access across the codebase. To add a constant value defined in cmake such that it is accessible in the source code (c++), the following method can be used.

\subsubsection{Defining C++ Accessible CMake Variables}

First, the value needs defined in the CMake using the \texttt{set} and \texttt{add\_definiition} methods:
\begin{lstlisting}[style=shellstyle]
# The version of the current MIA code.
set(MIA_VERSION_VAL "2.001")

# Add MIAVERSION as a preprocessor variable.
add_definitions( -DMIA_VERSION_VAL=\"${MIA_VERSION_VAL}\" )
\end{lstlisting}
These values can then be accessed within the source C++ code directly via
\begin{lstlisting}[style=cppstyle]
// The MIA Version value gathered from CMake.
inline const std::string MIA_VERSION = MIA_VERSION_VAL;
\end{lstlisting}
These values are typically added within the \texttt{Constants\_LIB} files which contains system related MIA constants. 

\subsection{Project Structure and Targets}

The project is organized into subdirectories for executables, libraries, resources, and tests:

\begin{itemize}
	\item \textbf{Executables:} Targets like \texttt{MIATemplate} are defined with source and header files, linked against core libraries, and have conditional install rules based on build options.
	\begin{lstlisting}[style=shellstyle]
# Create the MIATemplate executable.
set(MIATemplate_SRC MIATemplate.cpp MIATemplate_main.cpp )
set(MIATemplate_INC MIATemplate.hpp )
add_executable(MIATemplate ${MIATemplate_SRC} ${MIATemplate_INC} )
target_link_libraries(MIATemplate PRIVATE Core_LIB )

if(SYSTEM_INSTALL)
 install(TARGETS MIATemplate DESTINATION ${APP_INSTALL_LOCATION})
endif()

if(RELEASE_BUILD)
 install(TARGETS MIATemplate DESTINATION ${RELEASE_INSTALL_LOCATION})
endif()
	\end{lstlisting}
	\item \textbf{Libraries:} Utility libraries such as \texttt{Types\_LIB} are created from source files and expose their include directories for dependent targets. Libraries can link to other internal utilities or libraries.
	\begin{lstlisting}[style=shellstyle]
# Create the Types_LIB
set(Types_SRC StringUtils.cpp )
set(Types_INC StringUtils.hpp )
add_library(Types_LIB ${Types_SRC} ${Types_INC})
target_link_libraries( Types_LIB PUBLIC BasicUtilities_LIB )

# Expose this library's source directory for #include access by dependent targets
target_include_directories(Types_LIB PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
	\end{lstlisting}
	\item \textbf{Tests:} Test code is included via a dedicated subdirectory.
	\begin{lstlisting}[style=shellstyle]
# Include the test directory.
add_subdirectory( test )
	\end{lstlisting}
	\item \textbf{Resources:} Static resources are managed in their own subdirectory. These are primarily for configuration files and other resources. These are installed via the \texttt{FILES} Cmake keyword as follows:
	\begin{lstlisting}[style=shellstyle]
set(MIA_Config_Files
    MIATemplate.MIA
	# Other files here...
)

if(SYSTEM_INSTALL)
    install(FILES ${MIA_Config_Files} DESTINATION ${DEFAULT_SYSTEM_CONFIG_FILE_DIR})
endif()

if(RELEASE_BUILD)
    install(FILES ${MIA_Config_Files} DESTINATION ${RELEASE_CONFIG_INSTALL_LOCATION})
endif()
	\end{lstlisting}
\end{itemize}

\subsection{Installation Rules}

Conditional install commands allow targets to be installed either to system-wide locations or release-specific directories based on build flags (seen in the above shown cmake blocks). This supports flexible deployment workflows for development, testing, and production release. Overall, the CMake setup provides a structured, modular, and configurable build environment that adapts to different platforms and build scenarios while maintaining centralized control over important variables and paths.


















\section{Application Framework}
\label{sec:app-framework}

\subsection*{Overview}
The application framework provides a minimal structure for C++ applications that follow a consistent life cycle. It enforces a standard interface consisting of initialization and execution phases, and offers utilities to streamline application entry point definition. The design leverages C++20 concepts and templates for compile-time enforcement of interface contracts.

\subsection*{Life Cycle Model}
Applications using this framework must implement the following life cycle methods:
\begin{itemize}
	\item \texttt{void initialize(int argc, char** argv)} \\
	Performs startup logic, such as argument parsing and resource allocation.
	\item \texttt{int run()} \\
	Contains the main execution logic of the application. The return value is propagated as the process exit code.
\end{itemize}

\subsection*{Interface Enforcement}
The framework uses a C++20 concept, \texttt{AppInterface}, to statically constrain application types. This ensures that any type passed to the launcher function conforms to the expected interface, eliminating runtime errors due to missing methods.

\subsection*{Application Launch}
Applications are launched using the \texttt{runApp} template function:
\begin{itemize}
	\item Accepts any type satisfying \texttt{AppInterface}.
	\item Calls \texttt{initialize} followed by \texttt{run}, in that order.
	\item Returns the result of \texttt{run} as the application's exit code.
\end{itemize}

\subsection*{Entry Point Definition}
To reduce boilerplate and unify application entry points, the framework provides a macro:
\begin{itemize}
	\item \texttt{MIA\_MAIN(AppClass)} defines a \texttt{main()} function that delegates to \texttt{runApp<AppClass>}.
	\item This enables consistent startup across applications while preserving type safety and clarity.
\end{itemize}

\subsection*{Usage Guidelines}
\begin{enumerate}
	\item Define an application class that implements the required \texttt{initialize} and \texttt{run} methods.
	\item Use \texttt{MIA\_MAIN(YourAppClass);} in a translation unit to define the application entry point.
	\item Avoid manual \texttt{main()} definitions to preserve uniform lifecycle management.
\end{enumerate}

\subsection*{Benefits}
\begin{itemize}
	\item Promotes a consistent lifecycle across applications.
	\item Enables interface enforcement at compile time.
	\item Minimizes boilerplate in entry point logic.
	\item Facilitates cleaner and more maintainable application architecture.
\end{itemize}











\section{Base Application Class: \texttt{MIAApplication}}
\label{sec:base-application}

\subsection*{Overview}
The base MIA Application (see \texttt{MIAApplication.hpp}) serves as the foundational base class for applications built using the framework. It defines a standardized interface for application lifecycle methods and provides shared functionality for command-line argument parsing, particularly handling common flags such as \texttt{-v} (verbose) and \texttt{-h} (help).

\subsection*{Purpose}
This class is intended to be subclassed by specific applications. It provides default behavior for argument parsing and flag handling, while enforcing the implementation of core logic via a pure virtual \texttt{run()} method.

\subsection*{Initialization Interface}
\begin{itemize}
	\item \texttt{virtual void initialize(int argc, char* argv[])} \\
	Handles initial setup, including parsing common command-line arguments. 
	Derived classes should override this method to extend parsing logic but should still invoke the base implementation to preserve flag handling.
\end{itemize}

\subsection*{Execution Interface}
\begin{itemize}
	\item \texttt{virtual int run() = 0} \\
	Pure virtual function that must be implemented by all derived classes. It defines the main operational logic of the application and must return an integer exit code.
\end{itemize}

\subsection*{Flag Handling}
\begin{itemize}
	\item Verbose mode is handled internally and can be queried via \texttt{getVerboseMode()}.
	\item Help flag status is stored and can be utilized to trigger usage messages.
	\item \texttt{printHelp()} provides a virtual method to emit shared help information; it can be extended or overridden by subclasses.
\end{itemize}

\subsection*{Protected Members}
\begin{itemize}
	\item \texttt{bool verboseMode} \\
	Indicates whether verbose output was requested.
	\item \texttt{bool helpRequested} \\
	Set to \texttt{true} if the user requested help via the command-line.
\end{itemize}

\subsection*{Usage Guidelines}
\begin{enumerate}
	\item Inherit from \texttt{MIAApplication}.
	\item Override \texttt{initialize()} to add application-specific argument parsing; call the base method to retain common flag handling.
	\item Implement the \texttt{run()} method with the application's main logic.
	\item Use \texttt{getVerboseMode()} to conditionally enable verbose output.
\end{enumerate}

\subsection*{Benefits}
\begin{itemize}
	\item Standardizes lifecycle structure across applications.
	\item Centralizes command-line flag logic.
	\item Reduces redundancy in application setup.
	\item Encourages consistent help and verbose interfaces.
\end{itemize}










\section{Command Option System}

The command option system provides structured parsing and management of command-line arguments. It is composed of two main components: the \texttt{CommandOption} class and the \texttt{command\_parser} namespace. Together, they offer a consistent and type-safe interface for defining, parsing, and validating command-line options.

\subsection{CommandOption Class}

The \texttt{CommandOption} class encapsulates metadata and behavior for individual command-line arguments. It supports a variety of data types and provides a standardized help display format.

\subsubsection*{Key Features}
\begin{itemize}
	\item \textbf{Supported Types:} Defined by the \texttt{commandOptionType} enum:
	\begin{itemize}
		\item \texttt{boolOption}
		\item \texttt{intOption}
		\item \texttt{doubleOption}
		\item \texttt{stringOption}
	\end{itemize}
	
	\item \textbf{Constructor:} Accepts short/long argument forms, a description, data type, and a \texttt{required} flag.
	
	\item \textbf{Help Output:} \texttt{getHelp()} returns a formatted string of the form:
	\begin{verbatim}
		-s, --long        Description
	\end{verbatim}
	
	\item \textbf{Value Parsing:} The \texttt{getOptionVal<Type>} method retrieves the typed value from the command-line using appropriate dispatch.
	
	\item \textbf{Error Handling:} Throws \texttt{MIAException} if a type mismatch occurs or parsing fails.
\end{itemize}

\subsection{command\_parser Namespace}

This namespace implements the actual logic for extracting typed values from \texttt{argc}/\texttt{argv}. Each function accepts short and long option names, and a reference to the variable where the parsed value should be stored.

\subsubsection*{Parsing Functions}
\begin{itemize}
	\item \texttt{void parseBoolFlag(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, bool\& outValue);}
	\item \texttt{void parseIntOption(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, int\& outValue, bool required = false);}
	\item \texttt{void parseDoubleOption(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, double\& outValue, bool required = false);}
	\item \texttt{void parseStringOption(int argc, char* argv[], const std::string\& shortArg, const std::string\& longArg, std::string\& outValue, bool required = false);}
\end{itemize}

\subsubsection*{Behavior}
Each parser:
\begin{itemize}
	\item Validates the presence of the option.
	\item Converts the argument to the correct type.
	\item Throws a \texttt{MIAException} on error, such as type mismatch or missing required value.
\end{itemize}

\subsection{Integration}

The \texttt{CommandOption} class acts as a high-level interface, while \texttt{command\_parser} performs the low-level parsing. Together, they ensure robustness, type safety, and consistent error reporting across the command-line interface.














\section{Error Handling Framework}
\label{sec:error-handling}

\subsection*{Overview}
The MIA error handling system provides a structured and consistent mechanism for reporting, categorizing, and propagating errors throughout MIA applications. It is centered around a custom exception type (\texttt{MIAException}) and an extensible set of error codes defined via the \texttt{ErrorCode} enumeration.

\subsection*{Error Codes}
The \texttt{ErrorCode} enumeration defines a comprehensive list of standardized error values used throughout the MIA framework. These include:
\begin{itemize}
	\item System-aligned codes (e.g., \texttt{Access\_denied = 5})
	\item Application-specific codes starting at 31415 (i.e., \texttt{int}($\pi$ × 10000)), e.g., \texttt{Feature\_In\_Dev}
	\item Custom fatal and configuration errors (e.g., \texttt{FATAL\_File\_Not\_Found}, \texttt{Config\_File\_Not\_Set})
\end{itemize}

Each error code is associated with a human-readable description defined in \texttt{ErrorDescriptions.hpp}, accessible via:
\begin{lstlisting}[style=cppstyle]
const std::string& getErrorDescription(ErrorCode code);
\end{lstlisting}

\subsection*{MIAException Class}
The primary mechanism for structured error propagation is the \texttt{MIAException} class:
\begin{itemize}
	\item Inherits from \texttt{std::exception}.
	\item Encapsulates an \texttt{ErrorCode} and an optional detailed message.
	\item Supports integration with standard C++ \texttt{try/catch} error handling.
\end{itemize}

\textbf{Interface Summary:}
\begin{itemize}
	\item \texttt{MIAException(ErrorCode, const std::string\& details = "")} \\
	Constructs an exception with a specific code and optional extra context.
	\item \texttt{const char* what() const noexcept} \\
	Returns a descriptive error string combining code-based and contextual information.
	\item \texttt{ErrorCode getCode() const noexcept} \\
	Retrieves the error code associated with the exception.
\end{itemize}

\subsection*{Deprecated Legacy Functions}
Several older functions exist but are marked deprecated in favor of \texttt{MIAException}:
\begin{itemize}
	\item \texttt{returnError()}, \texttt{errorInfo()}, and \texttt{errorInfoRun()} are retained for backward compatibility but should be avoided.
	\item These are flagged with \texttt{[[deprecated]]} attributes.
\end{itemize}

\subsection*{Usage Guidelines}
\begin{enumerate}
	\item Throw \texttt{MIAException} in place of manual error returns.
	\item Use \texttt{getErrorDescription()} to log or report known error codes.
	\item Check exception codes via \texttt{getCode()} in catch blocks to take context-specific actions.
\end{enumerate}

\subsection*{Benefits}
\begin{itemize}
	\item Unifies error handling across the application ecosystem.
	\item Enables richer debugging and logging through descriptive errors.
	\item Supports granular response logic based on typed error codes.
\end{itemize}








\section{Global Constants and Paths}

This section documents the centralized constants and path utilities used across the application. These components standardize access to configuration values, resource locations, and metadata such as the application version.

\subsection{constants Namespace}

The \texttt{constants} namespace provides globally accessible constant values compiled into the application.

\subsubsection*{Defined Constant}
\begin{itemize}
	\item \texttt{MIA\_VERSION}: A \texttt{std::string} representing the version of the MIA application, injected from CMake via the \texttt{MIA\_VERSION\_VAL} macro.
\end{itemize}

\subsection{paths Namespace}

The \texttt{paths} namespace offers a centralized interface for accessing directory and file paths used by the system. These include installation-specific and repository-relative locations, as well as runtime-determined paths.

\subsubsection*{Static Path Constants}
\begin{itemize}
	\item \texttt{SYSTEM\_CONFIG\_FILE\_DIR}, \texttt{SYSTEM\_CONFIG\_FILE}: Paths to the configuration directory and file for system installations.
	\item \texttt{REPO\_CONFIG\_FILE\_DIR}, \texttt{REPO\_CONFIG\_FILE}: Paths used during development and testing.
	\item \texttt{SYSTEM\_LOG\_DIR}, \texttt{SYSTEM\_LOG}: Default logging directory and file when installed.
	\item \texttt{REPO\_LOG\_DIR}, \texttt{REPO\_LOG}: Logging paths for repository use.
	\item \texttt{INSTALL\_LOCATION}: The root directory of the system installation.
\end{itemize}

\subsubsection*{Runtime Utilities}
\begin{itemize}
	\item \texttt{getExecutableDir()}: Returns the absolute directory of the running executable using platform-specific APIs.
	
	\item \texttt{isInstalled()}: Determines whether the application is running from the system-installed location by comparing the executable path with the install directory.
	
	\item \texttt{getDefaultConfigDirToUse()}: Selects the configuration directory based on execution context:
	\begin{itemize}
		\item If installed: returns \texttt{SYSTEM\_CONFIG\_FILE\_DIR}.
		\item If a \texttt{resources} folder exists in the executable directory: returns that path.
		\item Otherwise: returns \texttt{REPO\_CONFIG\_FILE\_DIR}.
	\end{itemize}
\end{itemize}

This design ensures portability and flexibility across different environments (development, testing, deployment), with consistent fallback logic and platform-agnostic path resolution.




















\section{Configuration System: \texttt{MIAConfig}}

The \texttt{MIAConfig} class provides a flexible and extensible interface for managing configuration data in the MIA system. It replaces the legacy \texttt{Configurator} from the previous MIA project. The system is designed using the PIMPL (Pointer to IMPLementation) idiom, encapsulating implementation details and allowing for multiple configuration types such as key-value pairs or raw-line formats (with the flexibility to add more later).

\subsection{Overview}

\begin{itemize}
	\item \texttt{MIAConfig} is the main public interface that users interact with.
	\item \texttt{ConfigData} is an abstract base class defining the interface for internal configuration storage.
	\item \texttt{KeyValueData} is a concrete implementation of \texttt{ConfigData::KEY\_VALUE}, supporting standard key-value format parsing and access.
	\item \texttt{RawLinesData} is a concrete implementation of \texttt{ConfigData::RAW\_LINES}, supporting raw line format parsing and access.
	\item Configuration types are enumerated via \texttt{constants::ConfigType}.
\end{itemize}

\subsection{Key Features}

\begin{itemize}
	\item Supports setting and retrieving configuration files and types dynamically.
	\item Provides typed accessors: \texttt{getInt()}, \texttt{getDouble()}, \texttt{getString()}, \texttt{getBool()}, and vector versions.
	\item Supports verbose logging during file parsing for debugging.
	\item Can return all configuration entries as key-value pairs or raw lines, depending on the format.
\end{itemize}

\subsection{Class Hierarchy and Responsibilities}

\begin{description}
	\item[\texttt{MIAConfig}] 
	\hfill \\
	Acts as the front-end API. It delegates all data handling to the \texttt{ConfigData} object through a \texttt{std::unique\_ptr}.
	
	\item[\texttt{ConfigData}] 
	\hfill \\
	Abstract base class defining the required interface for data handling implementations. Includes methods for loading, retrieving, and dumping configuration data.
	
	\item[\texttt{KeyValueData}]
	\hfill \\
	Implements \texttt{ConfigData}. Parses files formatted with \texttt{key=value} lines into an internal map and supports type conversion and retrieval.
	
	\item[\texttt{RawLinesData}]
	\hfill \\
	Implements \texttt{ConfigData}. Parses files formatted with \texttt{any} format (parsed by line)i nto an internal vector and supports retrieval for custom parsing.
\end{description}

\subsection{Usage Pattern}

\begin{enumerate}
	\item Instantiate \texttt{MIAConfig} with a file name and configuration type.
	\item Call \texttt{initialize()} to parse and load the configuration file.
	\item Use the typed getter methods to retrieve settings.
\end{enumerate}

\subsection{Example}

\begin{verbatim}
	MIAConfig cfg("settings.conf", constants::ConfigType::KEY_VALUE);
	cfg.initialize();
	int timeout = cfg.getInt("network.timeout");
\end{verbatim}

\subsection{Extensibility}

New configuration formats can be supported by deriving new classes from \texttt{ConfigData} and implementing the required interface. \texttt{MIAConfig} will manage the polymorphic pointer and delegate appropriately based on the \texttt{ConfigType}.








